// Code generated by Kitex v0.16.1. DO NOT EDIT.

package karpo_persona

import (
	"context"
	"strconv"

	"github.com/cloudwego/prutal"
)

// Pipeline type for test execution.
type PipelineType int32

const (
	PipelineType_PIPELINE_TYPE_UNSPECIFIED PipelineType = 0
	PipelineType_PIPELINE_TYPE_ABSORB      PipelineType = 1
	PipelineType_PIPELINE_TYPE_RECALL      PipelineType = 2
)

// Enum value maps for PipelineType.
var PipelineType_name = map[int32]string{
	0: "PIPELINE_TYPE_UNSPECIFIED",
	1: "PIPELINE_TYPE_ABSORB",
	2: "PIPELINE_TYPE_RECALL",
}

var PipelineType_value = map[string]int32{
	"PIPELINE_TYPE_UNSPECIFIED": 0,
	"PIPELINE_TYPE_ABSORB":      1,
	"PIPELINE_TYPE_RECALL":      2,
}

func (x PipelineType) String() string {
	s, ok := PipelineType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}

type HealthCheckRequest struct {
}

func (x *HealthCheckRequest) Reset() { *x = HealthCheckRequest{} }

func (x *HealthCheckRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *HealthCheckRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

type HealthCheckResponse struct {
	// Service health status, e.g. "ok".
	Status string `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`

	// Service version string.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (x *HealthCheckResponse) Reset() { *x = HealthCheckResponse{} }

func (x *HealthCheckResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *HealthCheckResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *HealthCheckResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *HealthCheckResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

// A single content part within a message.
type ContentPart struct {
	// Content type, e.g. "text".
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`

	// Text content.
	Text string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
}

func (x *ContentPart) Reset() { *x = ContentPart{} }

func (x *ContentPart) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *ContentPart) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *ContentPart) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ContentPart) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

// A conversation message with role and content parts.
type Message struct {
	// Role: "user" or "assistant".
	Role string `protobuf:"bytes,1,opt,name=role" json:"role,omitempty"`

	// Message content parts.
	Content []*ContentPart `protobuf:"bytes,2,rep,name=content" json:"content,omitempty"`
}

func (x *Message) Reset() { *x = Message{} }

func (x *Message) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *Message) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *Message) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *Message) GetContent() []*ContentPart {
	if x != nil {
		return x.Content
	}
	return nil
}

// Configuration for a single pipeline step.
// Provided by the caller (persona-api) from published pipeline versions.
type StepConfig struct {
	// Step identifier, e.g. "extract_records", "dedup_check".
	StepId string `protobuf:"bytes,1,opt,name=step_id" json:"step_id,omitempty"`

	// Step type: "rule", "llm", or "rule_llm".
	StepType string `protobuf:"bytes,2,opt,name=step_type" json:"step_type,omitempty"`

	// LLM model identifier, e.g. "openai/gpt-4o-mini".
	Model string `protobuf:"bytes,3,opt,name=model" json:"model,omitempty"`

	// LLM sampling temperature (0.0-1.0).
	Temperature float64 `protobuf:"fixed64,4,opt,name=temperature" json:"temperature,omitempty"`

	// Maximum tokens for LLM response.
	MaxTokens int32 `protobuf:"varint,5,opt,name=max_tokens" json:"max_tokens,omitempty"`

	// Prompt template blocks keyed by block name (task, rules, examples, context, output, input).
	// Values are Go text/template strings with variables like {{ .Query }}.
	PromptBlocks map[string]string `protobuf:"bytes,6,rep,name=prompt_blocks" json:"prompt_blocks,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (x *StepConfig) Reset() { *x = StepConfig{} }

func (x *StepConfig) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *StepConfig) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *StepConfig) GetStepId() string {
	if x != nil {
		return x.StepId
	}
	return ""
}

func (x *StepConfig) GetStepType() string {
	if x != nil {
		return x.StepType
	}
	return ""
}

func (x *StepConfig) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *StepConfig) GetTemperature() float64 {
	if x != nil {
		return x.Temperature
	}
	return 0
}

func (x *StepConfig) GetMaxTokens() int32 {
	if x != nil {
		return x.MaxTokens
	}
	return 0
}

func (x *StepConfig) GetPromptBlocks() map[string]string {
	if x != nil {
		return x.PromptBlocks
	}
	return nil
}

// Request to absorb conversation messages into memory.
type AbsorbRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`

	// Conversation messages to absorb.
	Messages []*Message `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`

	// Optional metadata key-value pairs.
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`

	// Pipeline ID (snowflake int64). Zero means use default.
	PipelineId int64 `protobuf:"varint,4,opt,name=pipeline_id" json:"pipeline_id,omitempty"`

	// Optional pipeline version override.
	PipelineVersion *int32 `protobuf:"varint,5,opt,name=pipeline_version" json:"pipeline_version,omitempty"`

	// Enable debug trace output.
	Debug bool `protobuf:"varint,6,opt,name=debug" json:"debug,omitempty"`

	// Pipeline step configurations resolved from published pipeline version.
	// Required — engine will reject requests without step configs.
	StepConfigs []*StepConfig `protobuf:"bytes,7,rep,name=step_configs" json:"step_configs,omitempty"`
}

func (x *AbsorbRequest) Reset() { *x = AbsorbRequest{} }

func (x *AbsorbRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *AbsorbRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *AbsorbRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *AbsorbRequest) GetMessages() []*Message {
	if x != nil {
		return x.Messages
	}
	return nil
}

func (x *AbsorbRequest) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *AbsorbRequest) GetPipelineId() int64 {
	if x != nil {
		return x.PipelineId
	}
	return 0
}

func (x *AbsorbRequest) GetPipelineVersion() int32 {
	if x != nil && x.PipelineVersion != nil {
		return *x.PipelineVersion
	}
	return 0
}

func (x *AbsorbRequest) GetDebug() bool {
	if x != nil {
		return x.Debug
	}
	return false
}

func (x *AbsorbRequest) GetStepConfigs() []*StepConfig {
	if x != nil {
		return x.StepConfigs
	}
	return nil
}

// A record created or updated during absorb.
type RecordChange struct {
	// Record ID (snowflake int64).
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`

	// Record content text.
	Content string `protobuf:"bytes,2,opt,name=content" json:"content,omitempty"`

	// Category name this record belongs to.
	Category string `protobuf:"bytes,3,opt,name=category" json:"category,omitempty"`

	// Confidence score (0.0-1.0).
	Confidence float64 `protobuf:"fixed64,4,opt,name=confidence" json:"confidence,omitempty"`

	// IDs of records this one supersedes (snowflake int64).
	SupersededIds []int64 `protobuf:"varint,5,rep,packed,name=superseded_ids" json:"superseded_ids,omitempty"`
}

func (x *RecordChange) Reset() { *x = RecordChange{} }

func (x *RecordChange) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *RecordChange) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *RecordChange) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *RecordChange) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *RecordChange) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *RecordChange) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *RecordChange) GetSupersededIds() []int64 {
	if x != nil {
		return x.SupersededIds
	}
	return nil
}

// Response from the absorb pipeline.
type AbsorbResponse struct {
	// Source ID (snowflake int64) for the created source.
	SourceId int64 `protobuf:"varint,1,opt,name=source_id" json:"source_id,omitempty"`

	// Pipeline version used.
	PipelineVersion int32 `protobuf:"varint,2,opt,name=pipeline_version" json:"pipeline_version,omitempty"`

	// Records created during absorb.
	RecordsCreated []*RecordChange `protobuf:"bytes,3,rep,name=records_created" json:"records_created,omitempty"`

	// Records updated during absorb.
	RecordsUpdated []*RecordChange `protobuf:"bytes,4,rep,name=records_updated" json:"records_updated,omitempty"`

	// Category names whose summaries were updated.
	SummariesUpdated []string `protobuf:"bytes,5,rep,name=summaries_updated" json:"summaries_updated,omitempty"`

	// Trace URL for debugging.
	TraceUrl *string `protobuf:"bytes,6,opt,name=trace_url" json:"trace_url,omitempty"`

	// Pipeline execution duration in milliseconds.
	DurationMs *int64 `protobuf:"varint,7,opt,name=duration_ms" json:"duration_ms,omitempty"`
}

func (x *AbsorbResponse) Reset() { *x = AbsorbResponse{} }

func (x *AbsorbResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *AbsorbResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *AbsorbResponse) GetSourceId() int64 {
	if x != nil {
		return x.SourceId
	}
	return 0
}

func (x *AbsorbResponse) GetPipelineVersion() int32 {
	if x != nil {
		return x.PipelineVersion
	}
	return 0
}

func (x *AbsorbResponse) GetRecordsCreated() []*RecordChange {
	if x != nil {
		return x.RecordsCreated
	}
	return nil
}

func (x *AbsorbResponse) GetRecordsUpdated() []*RecordChange {
	if x != nil {
		return x.RecordsUpdated
	}
	return nil
}

func (x *AbsorbResponse) GetSummariesUpdated() []string {
	if x != nil {
		return x.SummariesUpdated
	}
	return nil
}

func (x *AbsorbResponse) GetTraceUrl() string {
	if x != nil && x.TraceUrl != nil {
		return *x.TraceUrl
	}
	return ""
}

func (x *AbsorbResponse) GetDurationMs() int64 {
	if x != nil && x.DurationMs != nil {
		return *x.DurationMs
	}
	return 0
}

// Request to recall memories matching a query.
type RecallRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`

	// Query text for memory recall.
	Query string `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`

	// Optional context key-value pairs.
	Context map[string]string `protobuf:"bytes,3,rep,name=context" json:"context,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`

	// Pipeline ID (snowflake int64). Zero means use default.
	PipelineId int64 `protobuf:"varint,4,opt,name=pipeline_id" json:"pipeline_id,omitempty"`

	// Optional pipeline version override.
	PipelineVersion *int32 `protobuf:"varint,5,opt,name=pipeline_version" json:"pipeline_version,omitempty"`

	// Enable debug trace output.
	Debug bool `protobuf:"varint,6,opt,name=debug" json:"debug,omitempty"`

	// Pipeline step configurations resolved from published pipeline version.
	// Required — engine will reject requests without step configs.
	StepConfigs []*StepConfig `protobuf:"bytes,7,rep,name=step_configs" json:"step_configs,omitempty"`
}

func (x *RecallRequest) Reset() { *x = RecallRequest{} }

func (x *RecallRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *RecallRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *RecallRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *RecallRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *RecallRequest) GetContext() map[string]string {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *RecallRequest) GetPipelineId() int64 {
	if x != nil {
		return x.PipelineId
	}
	return 0
}

func (x *RecallRequest) GetPipelineVersion() int32 {
	if x != nil && x.PipelineVersion != nil {
		return *x.PipelineVersion
	}
	return 0
}

func (x *RecallRequest) GetDebug() bool {
	if x != nil {
		return x.Debug
	}
	return false
}

func (x *RecallRequest) GetStepConfigs() []*StepConfig {
	if x != nil {
		return x.StepConfigs
	}
	return nil
}

// Recalled memories grouped under a single category.
type CategoryMemories struct {
	// Aggregated summary for this category.
	Summary string `protobuf:"bytes,1,opt,name=summary" json:"summary,omitempty"`

	// Individual recalled memory records.
	Records []*RecalledMemory `protobuf:"bytes,2,rep,name=records" json:"records,omitempty"`
}

func (x *CategoryMemories) Reset() { *x = CategoryMemories{} }

func (x *CategoryMemories) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *CategoryMemories) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *CategoryMemories) GetSummary() string {
	if x != nil {
		return x.Summary
	}
	return ""
}

func (x *CategoryMemories) GetRecords() []*RecalledMemory {
	if x != nil {
		return x.Records
	}
	return nil
}

// A single recalled memory record.
type RecalledMemory struct {
	// Memory content text.
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`

	// Category name.
	Category string `protobuf:"bytes,2,opt,name=category" json:"category,omitempty"`

	// Confidence score (0.0-1.0).
	Confidence *float64 `protobuf:"fixed64,3,opt,name=confidence" json:"confidence,omitempty"`

	// When this memory happened in RFC 3339 format, e.g. "2026-02-17T10:30:00.000Z".
	HappenedAt *string `protobuf:"bytes,4,opt,name=happened_at" json:"happened_at,omitempty"`
}

func (x *RecalledMemory) Reset() { *x = RecalledMemory{} }

func (x *RecalledMemory) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *RecalledMemory) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *RecalledMemory) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *RecalledMemory) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *RecalledMemory) GetConfidence() float64 {
	if x != nil && x.Confidence != nil {
		return *x.Confidence
	}
	return 0
}

func (x *RecalledMemory) GetHappenedAt() string {
	if x != nil && x.HappenedAt != nil {
		return *x.HappenedAt
	}
	return ""
}

// Response from the recall pipeline.
type RecallResponse struct {
	// Pipeline version used.
	PipelineVersion int32 `protobuf:"varint,1,opt,name=pipeline_version" json:"pipeline_version,omitempty"`

	// Recalled memories grouped by category name.
	Categories map[string]*CategoryMemories `protobuf:"bytes,2,rep,name=categories" json:"categories,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`

	// Trace URL for debugging.
	TraceUrl *string `protobuf:"bytes,3,opt,name=trace_url" json:"trace_url,omitempty"`

	// Pipeline execution duration in milliseconds.
	DurationMs *int64 `protobuf:"varint,4,opt,name=duration_ms" json:"duration_ms,omitempty"`
}

func (x *RecallResponse) Reset() { *x = RecallResponse{} }

func (x *RecallResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *RecallResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *RecallResponse) GetPipelineVersion() int32 {
	if x != nil {
		return x.PipelineVersion
	}
	return 0
}

func (x *RecallResponse) GetCategories() map[string]*CategoryMemories {
	if x != nil {
		return x.Categories
	}
	return nil
}

func (x *RecallResponse) GetTraceUrl() string {
	if x != nil && x.TraceUrl != nil {
		return *x.TraceUrl
	}
	return ""
}

func (x *RecallResponse) GetDurationMs() int64 {
	if x != nil && x.DurationMs != nil {
		return *x.DurationMs
	}
	return 0
}

// Request to list categories for a user.
type GetUserCategoriesRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`
}

func (x *GetUserCategoriesRequest) Reset() { *x = GetUserCategoriesRequest{} }

func (x *GetUserCategoriesRequest) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *GetUserCategoriesRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetUserCategoriesRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

// Summary information about a single category.
type CategoryInfo struct {
	// Category ID (snowflake int64).
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`

	// Category name.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`

	// Aggregated summary.
	Summary string `protobuf:"bytes,3,opt,name=summary" json:"summary,omitempty"`

	// Number of records in this category.
	RecordCount int32 `protobuf:"varint,4,opt,name=record_count" json:"record_count,omitempty"`
}

func (x *CategoryInfo) Reset() { *x = CategoryInfo{} }

func (x *CategoryInfo) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *CategoryInfo) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *CategoryInfo) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *CategoryInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CategoryInfo) GetSummary() string {
	if x != nil {
		return x.Summary
	}
	return ""
}

func (x *CategoryInfo) GetRecordCount() int32 {
	if x != nil {
		return x.RecordCount
	}
	return 0
}

// Response containing category list.
type GetUserCategoriesResponse struct {
	// List of categories.
	Categories []*CategoryInfo `protobuf:"bytes,1,rep,name=categories" json:"categories,omitempty"`
}

func (x *GetUserCategoriesResponse) Reset() { *x = GetUserCategoriesResponse{} }

func (x *GetUserCategoriesResponse) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *GetUserCategoriesResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetUserCategoriesResponse) GetCategories() []*CategoryInfo {
	if x != nil {
		return x.Categories
	}
	return nil
}

// Request to retrieve the user's memory graph.
type GetUserGraphRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`

	// Graph traversal depth (1-5, default 2).
	Depth *int32 `protobuf:"varint,2,opt,name=depth" json:"depth,omitempty"`
}

func (x *GetUserGraphRequest) Reset() { *x = GetUserGraphRequest{} }

func (x *GetUserGraphRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GetUserGraphRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetUserGraphRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *GetUserGraphRequest) GetDepth() int32 {
	if x != nil && x.Depth != nil {
		return *x.Depth
	}
	return 0
}

// A node in the memory graph.
type GraphNode struct {
	// Node identifier (string representation).
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`

	// Node type: "User", "Agent", "Category", "Record".
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`

	// Display label.
	Label string `protobuf:"bytes,3,opt,name=label" json:"label,omitempty"`

	// Additional properties.
	Properties map[string]string `protobuf:"bytes,4,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (x *GraphNode) Reset() { *x = GraphNode{} }

func (x *GraphNode) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GraphNode) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GraphNode) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *GraphNode) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *GraphNode) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *GraphNode) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// An edge in the memory graph.
type GraphEdge struct {
	// Source node identifier.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`

	// Target node identifier.
	Target string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`

	// Relationship type, e.g. "HAS_CATEGORY", "HAS_RECORD".
	Type string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`

	// Edge properties.
	Properties map[string]string `protobuf:"bytes,4,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (x *GraphEdge) Reset() { *x = GraphEdge{} }

func (x *GraphEdge) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GraphEdge) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GraphEdge) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *GraphEdge) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *GraphEdge) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *GraphEdge) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// Response containing the memory graph.
type GetUserGraphResponse struct {
	// Graph nodes.
	Nodes []*GraphNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`

	// Graph edges.
	Edges []*GraphEdge `protobuf:"bytes,2,rep,name=edges" json:"edges,omitempty"`
}

func (x *GetUserGraphResponse) Reset() { *x = GetUserGraphResponse{} }

func (x *GetUserGraphResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GetUserGraphResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetUserGraphResponse) GetNodes() []*GraphNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *GetUserGraphResponse) GetEdges() []*GraphEdge {
	if x != nil {
		return x.Edges
	}
	return nil
}

// Request to test a pipeline with sample input.
type TestPipelineRequest struct {
	// Pipeline type.
	PipelineType PipelineType `protobuf:"varint,1,opt,name=pipeline_type" json:"pipeline_type,omitempty"`

	// Pipeline ID (snowflake int64).
	PipelineId int64 `protobuf:"varint,2,opt,name=pipeline_id" json:"pipeline_id,omitempty"`

	// Optional pipeline version override.
	PipelineVersion *int32 `protobuf:"varint,3,opt,name=pipeline_version" json:"pipeline_version,omitempty"`

	// Test input text.
	Input string `protobuf:"bytes,4,opt,name=input" json:"input,omitempty"`
}

func (x *TestPipelineRequest) Reset() { *x = TestPipelineRequest{} }

func (x *TestPipelineRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *TestPipelineRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *TestPipelineRequest) GetPipelineType() PipelineType {
	if x != nil {
		return x.PipelineType
	}
	return PipelineType_PIPELINE_TYPE_UNSPECIFIED
}

func (x *TestPipelineRequest) GetPipelineId() int64 {
	if x != nil {
		return x.PipelineId
	}
	return 0
}

func (x *TestPipelineRequest) GetPipelineVersion() int32 {
	if x != nil && x.PipelineVersion != nil {
		return *x.PipelineVersion
	}
	return 0
}

func (x *TestPipelineRequest) GetInput() string {
	if x != nil {
		return x.Input
	}
	return ""
}

// Response from pipeline test.
type TestPipelineResponse struct {
	// Pipeline output.
	Output string `protobuf:"bytes,1,opt,name=output" json:"output,omitempty"`

	// Trace URL for debugging.
	TraceUrl *string `protobuf:"bytes,2,opt,name=trace_url" json:"trace_url,omitempty"`

	// Execution duration in milliseconds.
	DurationMs *int64 `protobuf:"varint,3,opt,name=duration_ms" json:"duration_ms,omitempty"`
}

func (x *TestPipelineResponse) Reset() { *x = TestPipelineResponse{} }

func (x *TestPipelineResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *TestPipelineResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *TestPipelineResponse) GetOutput() string {
	if x != nil {
		return x.Output
	}
	return ""
}

func (x *TestPipelineResponse) GetTraceUrl() string {
	if x != nil && x.TraceUrl != nil {
		return *x.TraceUrl
	}
	return ""
}

func (x *TestPipelineResponse) GetDurationMs() int64 {
	if x != nil && x.DurationMs != nil {
		return *x.DurationMs
	}
	return 0
}

// Request to list records for a user.
type GetRecordsRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`

	// Optional category name filter.
	Category *string `protobuf:"bytes,2,opt,name=category" json:"category,omitempty"`

	// Max records to return.
	Limit int32 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`

	// Offset for pagination.
	Offset int32 `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
}

func (x *GetRecordsRequest) Reset() { *x = GetRecordsRequest{} }

func (x *GetRecordsRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GetRecordsRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetRecordsRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *GetRecordsRequest) GetCategory() string {
	if x != nil && x.Category != nil {
		return *x.Category
	}
	return ""
}

func (x *GetRecordsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *GetRecordsRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// Detailed information about a single record.
type RecordDetail struct {
	// Record ID (snowflake int64).
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`

	// Record content text.
	Content string `protobuf:"bytes,2,opt,name=content" json:"content,omitempty"`

	// Category name.
	Category string `protobuf:"bytes,3,opt,name=category" json:"category,omitempty"`

	// Confidence score (0.0-1.0).
	Confidence float64 `protobuf:"fixed64,4,opt,name=confidence" json:"confidence,omitempty"`

	// When this happened in RFC 3339 format, e.g. "2026-02-17T10:30:00.000Z".
	HappenedAt *string `protobuf:"bytes,5,opt,name=happened_at" json:"happened_at,omitempty"`

	// Creation time in RFC 3339 format, e.g. "2026-02-17T10:30:00.000Z".
	CreatedAt string `protobuf:"bytes,6,opt,name=created_at" json:"created_at,omitempty"`
}

func (x *RecordDetail) Reset() { *x = RecordDetail{} }

func (x *RecordDetail) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *RecordDetail) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *RecordDetail) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *RecordDetail) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *RecordDetail) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *RecordDetail) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *RecordDetail) GetHappenedAt() string {
	if x != nil && x.HappenedAt != nil {
		return *x.HappenedAt
	}
	return ""
}

func (x *RecordDetail) GetCreatedAt() string {
	if x != nil {
		return x.CreatedAt
	}
	return ""
}

// Response containing record list.
type GetRecordsResponse struct {
	// List of records.
	Records []*RecordDetail `protobuf:"bytes,1,rep,name=records" json:"records,omitempty"`

	// Total number of records matching the filter.
	Total int32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`

	// Whether more records exist beyond this page.
	HasMore bool `protobuf:"varint,3,opt,name=has_more" json:"has_more,omitempty"`
}

func (x *GetRecordsResponse) Reset() { *x = GetRecordsResponse{} }

func (x *GetRecordsResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GetRecordsResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetRecordsResponse) GetRecords() []*RecordDetail {
	if x != nil {
		return x.Records
	}
	return nil
}

func (x *GetRecordsResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *GetRecordsResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

// Request to search records by vector similarity.
type SearchRecordsRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`

	// Search query text.
	Query string `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`

	// Optional category name filters.
	Categories []string `protobuf:"bytes,3,rep,name=categories" json:"categories,omitempty"`

	// Max results to return.
	Limit int32 `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
}

func (x *SearchRecordsRequest) Reset() { *x = SearchRecordsRequest{} }

func (x *SearchRecordsRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *SearchRecordsRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *SearchRecordsRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *SearchRecordsRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *SearchRecordsRequest) GetCategories() []string {
	if x != nil {
		return x.Categories
	}
	return nil
}

func (x *SearchRecordsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

// Response containing search results.
type SearchRecordsResponse struct {
	// Matching records.
	Records []*RecordDetail `protobuf:"bytes,1,rep,name=records" json:"records,omitempty"`
}

func (x *SearchRecordsResponse) Reset() { *x = SearchRecordsResponse{} }

func (x *SearchRecordsResponse) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *SearchRecordsResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *SearchRecordsResponse) GetRecords() []*RecordDetail {
	if x != nil {
		return x.Records
	}
	return nil
}

// Request to list sources linked to a record.
type GetRecordSourcesRequest struct {
	// Record ID (snowflake int64).
	RecordId int64 `protobuf:"varint,1,opt,name=record_id" json:"record_id,omitempty"`

	// Max sources to return.
	Limit int32 `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`

	// Offset for pagination.
	Offset int32 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
}

func (x *GetRecordSourcesRequest) Reset() { *x = GetRecordSourcesRequest{} }

func (x *GetRecordSourcesRequest) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *GetRecordSourcesRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetRecordSourcesRequest) GetRecordId() int64 {
	if x != nil {
		return x.RecordId
	}
	return 0
}

func (x *GetRecordSourcesRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *GetRecordSourcesRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// Detailed information about a single source.
type SourceDetail struct {
	// Source ID (snowflake int64).
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`

	// Source type: "conversation", "image", "audio", "file".
	SourceType string `protobuf:"bytes,2,opt,name=source_type" json:"source_type,omitempty"`

	// Raw content text.
	Content *string `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`

	// Source URL.
	SourceUrl *string `protobuf:"bytes,4,opt,name=source_url" json:"source_url,omitempty"`

	// Metadata key-value pairs.
	Metadata map[string]string `protobuf:"bytes,5,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`

	// Creation time in RFC 3339 format, e.g. "2026-02-17T10:30:00.000Z".
	CreatedAt string `protobuf:"bytes,6,opt,name=created_at" json:"created_at,omitempty"`
}

func (x *SourceDetail) Reset() { *x = SourceDetail{} }

func (x *SourceDetail) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *SourceDetail) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *SourceDetail) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *SourceDetail) GetSourceType() string {
	if x != nil {
		return x.SourceType
	}
	return ""
}

func (x *SourceDetail) GetContent() string {
	if x != nil && x.Content != nil {
		return *x.Content
	}
	return ""
}

func (x *SourceDetail) GetSourceUrl() string {
	if x != nil && x.SourceUrl != nil {
		return *x.SourceUrl
	}
	return ""
}

func (x *SourceDetail) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SourceDetail) GetCreatedAt() string {
	if x != nil {
		return x.CreatedAt
	}
	return ""
}

// Response containing source list.
type GetRecordSourcesResponse struct {
	// List of sources.
	Sources []*SourceDetail `protobuf:"bytes,1,rep,name=sources" json:"sources,omitempty"`

	// Total number of sources.
	Total int32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`

	// Whether more sources exist beyond this page.
	HasMore bool `protobuf:"varint,3,opt,name=has_more" json:"has_more,omitempty"`
}

func (x *GetRecordSourcesResponse) Reset() { *x = GetRecordSourcesResponse{} }

func (x *GetRecordSourcesResponse) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *GetRecordSourcesResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetRecordSourcesResponse) GetSources() []*SourceDetail {
	if x != nil {
		return x.Sources
	}
	return nil
}

func (x *GetRecordSourcesResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *GetRecordSourcesResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

// Request to list history entries for a record.
type GetRecordHistoryRequest struct {
	// Record ID (snowflake int64).
	RecordId int64 `protobuf:"varint,1,opt,name=record_id" json:"record_id,omitempty"`

	// Max entries to return.
	Limit int32 `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`

	// Offset for pagination.
	Offset int32 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
}

func (x *GetRecordHistoryRequest) Reset() { *x = GetRecordHistoryRequest{} }

func (x *GetRecordHistoryRequest) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *GetRecordHistoryRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetRecordHistoryRequest) GetRecordId() int64 {
	if x != nil {
		return x.RecordId
	}
	return 0
}

func (x *GetRecordHistoryRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *GetRecordHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// A single history entry for a record.
type RecordHistoryEntry struct {
	// History entry ID (snowflake int64).
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`

	// Record ID (snowflake int64).
	RecordId int64 `protobuf:"varint,2,opt,name=record_id" json:"record_id,omitempty"`

	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,3,opt,name=user_id" json:"user_id,omitempty"`

	// Category name.
	Category string `protobuf:"bytes,4,opt,name=category" json:"category,omitempty"`

	// Action: "create" or "update".
	Action string `protobuf:"bytes,5,opt,name=action" json:"action,omitempty"`

	// Previous content (for updates).
	OldContent *string `protobuf:"bytes,6,opt,name=old_content" json:"old_content,omitempty"`

	// New content.
	NewContent string `protobuf:"bytes,7,opt,name=new_content" json:"new_content,omitempty"`

	// Creation time in RFC 3339 format, e.g. "2026-02-17T10:30:00.000Z".
	CreatedAt string `protobuf:"bytes,8,opt,name=created_at" json:"created_at,omitempty"`
}

func (x *RecordHistoryEntry) Reset() { *x = RecordHistoryEntry{} }

func (x *RecordHistoryEntry) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *RecordHistoryEntry) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *RecordHistoryEntry) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *RecordHistoryEntry) GetRecordId() int64 {
	if x != nil {
		return x.RecordId
	}
	return 0
}

func (x *RecordHistoryEntry) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *RecordHistoryEntry) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *RecordHistoryEntry) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *RecordHistoryEntry) GetOldContent() string {
	if x != nil && x.OldContent != nil {
		return *x.OldContent
	}
	return ""
}

func (x *RecordHistoryEntry) GetNewContent() string {
	if x != nil {
		return x.NewContent
	}
	return ""
}

func (x *RecordHistoryEntry) GetCreatedAt() string {
	if x != nil {
		return x.CreatedAt
	}
	return ""
}

// Response containing record history.
type GetRecordHistoryResponse struct {
	// History entries.
	History []*RecordHistoryEntry `protobuf:"bytes,1,rep,name=history" json:"history,omitempty"`

	// Total number of entries.
	Total int32 `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`

	// Whether more entries exist beyond this page.
	HasMore bool `protobuf:"varint,3,opt,name=has_more" json:"has_more,omitempty"`
}

func (x *GetRecordHistoryResponse) Reset() { *x = GetRecordHistoryResponse{} }

func (x *GetRecordHistoryResponse) Marshal(in []byte) ([]byte, error) {
	return prutal.MarshalAppend(in, x)
}

func (x *GetRecordHistoryResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetRecordHistoryResponse) GetHistory() []*RecordHistoryEntry {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *GetRecordHistoryResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *GetRecordHistoryResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

// Request to get statistics for a user.
type GetUserStatsRequest struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`
}

func (x *GetUserStatsRequest) Reset() { *x = GetUserStatsRequest{} }

func (x *GetUserStatsRequest) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GetUserStatsRequest) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetUserStatsRequest) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

// Response containing user statistics.
type GetUserStatsResponse struct {
	// User ID (snowflake int64).
	UserId int64 `protobuf:"varint,1,opt,name=user_id" json:"user_id,omitempty"`

	// Number of categories.
	CategoryCount int32 `protobuf:"varint,2,opt,name=category_count" json:"category_count,omitempty"`

	// Number of records.
	RecordCount int32 `protobuf:"varint,3,opt,name=record_count" json:"record_count,omitempty"`

	// Number of sources.
	SourceCount int32 `protobuf:"varint,4,opt,name=source_count" json:"source_count,omitempty"`

	// Last updated time in RFC 3339 format, e.g. "2026-02-17T10:30:00.000Z".
	LastUpdated *string `protobuf:"bytes,5,opt,name=last_updated" json:"last_updated,omitempty"`
}

func (x *GetUserStatsResponse) Reset() { *x = GetUserStatsResponse{} }

func (x *GetUserStatsResponse) Marshal(in []byte) ([]byte, error) { return prutal.MarshalAppend(in, x) }

func (x *GetUserStatsResponse) Unmarshal(in []byte) error { return prutal.Unmarshal(in, x) }

func (x *GetUserStatsResponse) GetUserId() int64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *GetUserStatsResponse) GetCategoryCount() int32 {
	if x != nil {
		return x.CategoryCount
	}
	return 0
}

func (x *GetUserStatsResponse) GetRecordCount() int32 {
	if x != nil {
		return x.RecordCount
	}
	return 0
}

func (x *GetUserStatsResponse) GetSourceCount() int32 {
	if x != nil {
		return x.SourceCount
	}
	return 0
}

func (x *GetUserStatsResponse) GetLastUpdated() string {
	if x != nil && x.LastUpdated != nil {
		return *x.LastUpdated
	}
	return ""
}

type PersonaEngineService interface {
	HealthCheck(ctx context.Context, req *HealthCheckRequest) (res *HealthCheckResponse, err error)
	Absorb(ctx context.Context, req *AbsorbRequest) (res *AbsorbResponse, err error)
	Recall(ctx context.Context, req *RecallRequest) (res *RecallResponse, err error)
	GetUserCategories(ctx context.Context, req *GetUserCategoriesRequest) (res *GetUserCategoriesResponse, err error)
	GetUserGraph(ctx context.Context, req *GetUserGraphRequest) (res *GetUserGraphResponse, err error)
	TestPipeline(ctx context.Context, req *TestPipelineRequest) (res *TestPipelineResponse, err error)
	GetRecords(ctx context.Context, req *GetRecordsRequest) (res *GetRecordsResponse, err error)
	SearchRecords(ctx context.Context, req *SearchRecordsRequest) (res *SearchRecordsResponse, err error)
	GetRecordSources(ctx context.Context, req *GetRecordSourcesRequest) (res *GetRecordSourcesResponse, err error)
	GetRecordHistory(ctx context.Context, req *GetRecordHistoryRequest) (res *GetRecordHistoryResponse, err error)
	GetUserStats(ctx context.Context, req *GetUserStatsRequest) (res *GetUserStatsResponse, err error)
}
